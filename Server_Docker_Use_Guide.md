
# [랩실 서버] Docker 사용 및 안전 수칙 가이드

본 문서는 **Ubuntu 22.04 / NVIDIA RTX A6000** 기반의 공용 랩실 서버에서, 여러 사용자가 충돌 없이 안전하게 로봇 제어(ROS 2, GO1) 및 딥러닝 환경을 구축하기 위한 표준 절차를 규정합니다.

서버의 안정적인 운영(부팅 불량 방지, 디스크 관리)을 위해 모든 팀원은 아래 수칙을 반드시 준수해주시기 바랍니다.

# 0. 서버 안전을 위한 필수 수칙 (필독)

서버가 멈추거나 부팅이 안 되는 사고를 방지하기 위해 다음 4가지를 금지/권장합니다.

**1. --restart always 옵션 사용 금지 (절대 엄수)**

오류가 있는 컨테이너가 무한 재부팅 되면 서버 CPU/RAM을 100% 점유하여 서버 자체가 먹통이 될 수 있습니다.

**2. sudo 명령어 사용 불필요**

이미 계정에 Docker 권한이 부여되어 있습니다. 파일 소유권 꼬임 방지를 위해 sudo docker ... 대신 그냥 docker ...를 사용하세요.


**3. 컨테이너 유형에 따른 관리 (재사용 vs 삭제)**

지속용 (로봇 통신/개발): docker stop으로 멈추고, docker start로 재사용합니다. (삭제 X)

일회용 (단순 테스트): 실행 시 --rm 옵션을 붙여 종료 후 자동 삭제되게 합니다. (디스크 낭비 방지)

**4. 포트 및 리소스 충돌 주의**

--net=host 사용 시 다른 사용자와 포트가 겹치지 않도록 주의합니다. (ROS_DOMAIN_ID 등 확인)

# 1단계: 작업 디렉토리 생성 (Workspace Setup)

도커 컨테이너는 삭제될 수 있지만, 작성한 코드와 데이터는 영구적으로 보존되어야 합니다. 

따라서 호스트(서버)에 프로젝트 폴더를 만들고 이를 도커와 연결(Mount)하는 방식을 사용합니다.

# 1.1 홈 디렉토리 내 폴더 생성
모든 작업은 반드시 /home/[본인ID]/ 경로 내에서 이루어져야 합니다. 

시스템 폴더(/var, /opt 등)나 다른 팀원의 폴더를 침범하지 마세요.

터미널을 열고(SSH 접속) 아래 명령어로 프로젝트 폴더를 생성합니다. 

**아래의 명령어는 예시로, 그대로 따라하지 마시고 작업시에 필요한대로 별도의 디렉토리를 생성해야 합니다.**

```
# 홈 디렉토리로 이동
cd ~

# 프로젝트 폴더 생성 (예: robomaster_project. 각자 다른 이름을 설정해야 함.)
mkdir -p ~/robomaster_project/src
mkdir -p ~/robomaster_project/data

# 생성 확인
ls -F ~/robomaster_project/
```

# 2단계 :  Dockerfile 준비
생성한 프로젝트 폴더 안으로 이동하여, 도커 이미지를 만들기 위한 명세서(Dockerfile)를 준비합니다. 

(예전 가이드를 기준으로 작성된 예시입니다.)

```
cd ~/robomaster_project
nano Dockerfile
```

dockerfile을 작성할 때, 아래의 예시 코드처럼 **Workdir(작업경로)에 유의하시기 바랍니다.** 

현재 작업하는 폴더의 이름이 들어가야합니다.


또한, apt-get install 이후 rm -rf /var/lib/apt/lists/* 를 하는것이 이미지 용량을 줄일 수 있습니다.


**아래의 코드는 구조를 보여주는 예시 코드로, 그대로 실행시키지 않는 것이 좋습니다.**

```
WORKDIR /root/robomaster_project
RUN echo "source /opt/ros/foxy/setup.bash" >> ~/.bashrc

RUN apt-get update && apt-get install -y \
    python3-pip python3-colcon-common-extensions \
    git wget unzip && rm -rf /var/lib/apt/lists/*
```

# 3단계 : Docker 이미지 빌드
작성한 Dockerfile을 기반으로 실행 가능한 '도커 이미지'를 생성하는 단계입니다.

이 때, **반드시 Dockerfile이 있는 디렉토리에서 명령어를 실행**해야 하며 **공용 서버이므로 이미지 이름에 본인 이니셜을 포함하는 것을 권장합니다. (예: dg_ros_foxy)**

아래는 예시 코드입니다.

```
# 1. Dockerfile이 있는 위치로 이동 (필수)
cd ~/robomaster_project

# 2. 이미지 빌드 명령어
# 형식: docker build -t [이미지이름] . 
# (마지막의 온점 '.'은 '현재 폴더의 Dockerfile을 쓰겠다'는 뜻이므로 꼭 찍어야 합니다!)

docker build -t dg_robomaster_v1 .

```

# 4단계: 컨테이너 실행 (Run) - 🚨 가장 중요

컨테이너 실행 단계는 서버의 안정성과 직결됩니다. 잘못된 옵션을 사용하면 *서버 재부팅 시 부하를 일으켜 서버가 켜지지 않는 심각한 문제*가 발생할 수 있습니다. 

⚠️ **[필독] 절대 금지 및 필수 안전 수칙**

**1. --restart 옵션 사용 금지 (절대 엄수)**

--restart always 등을 사용하면, 코드 오류로 컨테이너가 죽을 때마다 무한 재부팅을 시도합니다. 이 과정에서 CPU가 폭주하여 서버가 먹통이 됩니다.  
서버가 꺼지면 컨테이너도 꺼져 있는 것이 정상입니다. 필요할 때 직접 켜야 합니다.

**2. --rm 옵션 활용 (일회용 테스트 시)**

단순히 동작을 확인하거나 짧게 테스트할 때는 --rm 옵션을 붙이는 것을 권장드립니다.  
컨테이너 종료(stop) 시 자동으로 삭제되어 디스크 용량을 보호합니다.  
만약 일회용 테스트 용도의 컨테이너가 수십개 쌓이면, 추후 도커 컨테이너의 식별 및 정리가 어려워집니다.

**3. --privileged (신중 사용)**

서버의 모든 하드웨어 제어권을 가져가는 옵션입니다.   
USB로 로봇을 직접 연결하는 경우가 아니라면 보안을 위해 빼는 것이 원칙입니다. (무선 연결 시 불필요)

**아래는 예시 목적의 컨테이너 실행 명령어입니다.** 그대로 실행하지 마시고, 예시 관련한 설명을 아래에 서술하겠습니다.  
필요한 부분의 코드 중 [ ]로 표시된 부분을 본인 정보로 바꿔서 실행하시면 됩니다.
```
# 중요: 역슬래시(\)를 포함하여 전체를 복사하세요. 역슬래시는 줄바꿈 용도의 문자입니다.

docker run -it -d \
  --name [이니셜_프로젝트명] \
  --gpus all \
  --net=host \
  -e ROS_DOMAIN_ID=[본인_고유번호] \
  -v ~/robomaster_project:/root/robomaster_project \
  [이미지이름]
```

**1. docker run -it과 docker run -it -d의 차이**
- docker run -it : ssh 접속 종료 / 인터넷 끊김 등으로 터미널이 닫히면 컨테이너도 종료됨. 만약 학습이 필요한 컨테이너를 실행할때 docker run -it 으로 컨테이너를 가동하면 터미널 종료시 컨테이너도 같이 종료.
- docker run -it -d : 컨테이너를 백그라운드에 실행. ssh 접속을 끊어도 컨테이너는 계속 실행됩니다. 학습 돌려놓고 컴퓨터 종료 가능. 이후 켜져있는 컨테이너에 docker exec 명령어로 들어갑니다.

**2. --gpus all**
- 이 컨테이너에게 서버에 있는 모든 GPU 장치에 접근할 수 있는 권한을 주겠다는 뜻입니다. AI 모델 사용시 해당 옵션을 켜야합니다.

**3. --net=host와 -e ROS_DOMAIN_ID=[본인_고유번호]**
- 로보마스터와 ROS 2는 네트워크상의 모든 노드를 자동으로 찾습니다. 따라서 동시에 컨테이너를 키면, A의 로봇 데이터가 B에게도 보이는 혼선이 발생할 수 있습니다.
- 따라서, ROS_DOMAIN_ID를 통해 컨테이너 실행 시 "나는 7번 채널 쓸게, 너는 8번 써"와 같은 환경변수를 지정해주는 것입니다. 팀원끼리 통신이 섞이지 않게 0~100 사이 숫자를 정해 각자 다른 번호를 넣으세요. (예: 철수 10, 영희 20)

**5. -v (볼륨 마운트)**
- ~/호스트경로:/컨테이너경로 가장 중요한 데이터 보호 옵션입니다. 코드는 서버(내 폴더)에 저장하고, 도커는 실행만 담당하게 합니다. 실수로 컨테이너가 삭제되어도 작성한 코드는 안전하게 보존됩니다.

**6. --shm-size**
- Pytorch 등 딥러닝 학습 시 Bus error 등 메모리 부족 에러가 발생하면 추가합니다. 예시: --shm-size=8G (서버 메모리를 넉넉하게 할당)

# 5단계: 컨테이너 접속, 중지 및 재사용 (Lifecycle)
컨테이너를 백그라운드(-d)로 실행한 경우에는, 작업을 하려면 터미널을 열고 컨테이너 내부로 진입해야 합니다.  
백그라운드로 실행하지 않았다면, 꺼진 컨테이너를 다시 작동시키고 진입해야 합니다.  
또한, 사용이 끝난 후에는 반드시 **중지**하여 GPU 자원을 반환해야 합니다.

**1. 실행 중인 컨테이너 접속 (exec)**
```
# 형식: docker exec -it [컨테이너이름] /bin/bash
docker exec -it dg_ep01_test /bin/bash

```

**2. 컨테이너 중지 (stop) - ⚠️ 사용 후 필수**  
작업이 완전히 끝나면(퇴근 시 등) 반드시 컨테이너를 멈춰야 합니다. 멈추지 않으면 GPU 메모리를 계속 점유하여 다른 사람이 사용하지 못합니다.
```
# 1. 내 컨테이너가 켜져 있는지 확인
docker ps

# 2. 컨테이너 끄기 (데이터는 날아가지 않음)
docker stop [컨테이너이름]
```

**3. 껐던 컨테이너 다시 켜기 (start) - 🚨 중요**  
이미 만들어진 컨테이너를 다시 쓸 때는 절대 docker run을 또 하지 마세요! (이러면 이름 충돌 에러가 뜨거나, 새 컨테이너가 또 생깁니다.)

```
# 1. 꺼져 있는 내 컨테이너 이름 확인
docker ps -a

# 2. 다시 시동 걸기 (Start)
docker start [컨테이너이름]

# 3. 접속하기 (Exec)
docker exec -it [컨테이너이름] /bin/bash
```

**4. 컨테이너 삭제 (rm)**  
더 이상 쓰지 않는 컨테이너는 삭제하여 디스크를 정리합니다.

```
# 먼저 중지(stop)한 후에 삭제 가능
docker stop [컨테이너이름]
docker rm [컨테이너이름]
```

----

이상으로 기본적인 서버에서 도커를 실행할 때 유의사항과 관련한 가이드 작성을 마치겠습니다.
